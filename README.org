#+AUTHOR: Tasos Fragkopoulos

* Εργασία Εξαμήνου Μαθηματικό Λογισμικό

** Άσκηση 1

*** Μέθοδος Επίλυσης

Για να λύσουμε την άσκηση θα πρέπει αρχικά να βρούμε τις ακτίνες κάθε κύκλου. Έστω κύκλοι A, B, C με κέντρα $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ και ακτίνες $R_1, R_2, R_3$ αντοίστοιχα, όπως φαίνεται στην εικόνα παρακάτω.

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[./ask1/outputImage.jpg]]

Ξέρωντας τα αυτά η απόσταση μεταξύ κάθε κέντρου θα είναι:

#+BEGIN_CENTER
    $AB = R_1 + R_2$

    $AC = R_1 + R_3$

    $BC = R_2 + R_3$
#+END_CENTER

Μπορούμε να λύσουμε για $R_1, R_2, R_3$ και να βρούμε ότι:

#+BEGIN_CENTER
    $R_1 = \frac{AB + AC - BC}{2}$

    $R_2 = \frac{AB - AC + BC}{2}$

    $R_1 = \frac{-AB + AC + BC}{2}$
#+END_CENTER

Επιπλέων ξέρουμε οτι:

#+BEGIN_CENTER
    $AB = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$

    $AC = \sqrt{(x_3 - x_1)^2 + (y_3 - y_1)^2}$

    $BC = \sqrt{(x_3 - x_2)^2 + (y_3 - y_2)^2}$
#+END_CENTER

Έτσι υπολογίζοντας αρχικά τα $AB, AC, BC$ και κάνοντας τις πράξεις θα βρούμε τα $R_1, R_2, R_3$

*** Επίλυση στο Matlab

Η βασική επίλυση του προβλήματος γίνεται στο αρχείο =drawCircles.m= που έχει δύο συναρτήσεις, την =drawCircles(x, y)= και την =circle(x, y, r)=. Επίσης υπάρχει το αρχείο =example.m= που τρέχει την συνάρτηση =drawCircles= με x, y τις τιμές που δώθηκαν απο την εκφώνηση ως παράδειγμα, την χρονομετρεί με την χρήση της συνάρτησης =timeit()= του Matlab και εκτυπώνει τον χρόνο.

Στη συνάρτηση =drawCircles(x, y)= αρχικά υπολογίζουμε τις τιμές AB, AC, BC.

#+BEGIN_SRC matlab
AB = sqrt((x(2) - x(1))^2 + (y(2) - y(1))^2);
AC = sqrt((x(3) - x(1))^2 + (y(3) - y(1))^2);
BC = sqrt((x(3) - x(2))^2 + (y(3) - y(2))^2);
#+END_SRC

Ένας άλλος τρόπος να τις υπολογίσουμε θα ήταν να χρησιμοποιήσουμε την συνάρτηση =norm()=.

Στην συνέχεια φτιάχνουμε ενα διάνυσμα R, στο οποίο θα βάλουμε τις τιμές των $R_1, R_2, R_3$ που θα υπολογίσουμε.

#+BEGIN_SRC matlab
R = [];
R(1) = ( AB + AC - BC)/2;
R(2) = ( AB - AC + BC)/2;
R(3) = (-AB + AC + BC)/2;
#+END_SRC

Τέλος κάνουμε plot τις ακμές του τριγώνου και τους κύκλους. Για τους κύκλους θα χρησιμοποιούμε την βοηθητική συνάρτηση =circle(x, y, r)= που βρίσκεται στο ίδιο αρχείο. Παίρνει ως ορίσματα τις συντεταγμένες (x, y) του κέντρου του κύκλου και το μήκος της ακτίνας του r και κάνει plot τον κάθε κύκλο.

#+BEGIN_SRC matlab
function circle(x, y, r)
% CIRCLE -
%
    th = 0:pi/50:2*pi;
    xunit = r * cos(th) + x;
    yunit = r * sin(th) + y;
    plot(xunit, yunit);
end
#+END_SRC
Σε αυτή ορίζουμε το διάνυσμα th που έχει τις τιμές από 0 μέχρι $2\pi$ με βήμα $\frac{\pi}{50}$ και μετά υπολογίζουμε τις x και y συντεταγμένες του κύκλου στις xunit και yunit αντίστοιχα.

** Άσκηση 2

*** Επίλυση στο Matlab

Ο υπολογισμός του e με τον τύπο
#+BEGIN_CENTER
$e = \lim_{n\rightarrow \infty}(1 + \frac{1}{n})^n$
#+end_center
γίνεται στο *matlab*:

#+begin_src matlab
while(abs(em - e) > tol)
    e = (1 + 1/n)^n;     % approximate e using formula
    n = n * 2;           % double the value of n in each iteration
    count = count + 1;   % increment the iteration count
end
#+end_src

η λούπα τρέχει όσο η απόλυτη διαφορά του e που υπολογίζουμε με του em (που είναι το e που δίνεται απο το matlab matlab =em = exp(1)=) είναι μεγαλύτερη του tol που είναι η ακρίβεια που θέλουμε που βγαίνει από =tol = 10^-(l + 1)=.
το n διπλασιάζεται σε κάθε, επανάληψη που είναι πολύ πιο αποτελεσματικό από την αύξηση του κατά ένα.

αποτέλεσμα συνάρτησης με διπλασιασμό n:
#+begin_src
>> approximate(9)
matlab's number: 	2.718281828459
approximated number: 	2.718281828380
accuracy to point: 	          ^
number of iterations: 	35
#+end_src

αποτέλεσμα συνάρτησης με αύξηση n κατα ένα:
#+begin_src
>> approximate(9)
matlab's number: 	2.718281828459
approximated number: 	2.718281828360
accuracy to point: 	          ^
number of iterations: 	66953800
#+end_src

*** Προβλήματα με την άσκηση

Το πρόβλημα με την συνάρτηση αυτή είναι ότι δεν δουλεύει για =l > 15=. Αυτό συμβαίνει γιατί το n γίνεται πολύ μεγάλο και έτσι το =1/n= είναι τόσο μικρό που το *Matlab* στην πρόσθεση του με το 1 αγνοεί τα δεκαδικά, με αποτέλεσμα το e να γίνει 1.

Μια λύση για να αντιμετοπίσουμε το πρόβλημα αυτό είναι να χρησιμοποιήσουμε την συνάρτηση =vpa()= του [[https://www.mathworks.com/help/symbolic/][*Symbolic Math Toolbox*]] για να κάνουμε την πράξη. Βέβαια κάνει την συνάρτηση πολύ πιο αργή.

Ο πιο αποτελεσματικός τρόπος είναι να χρησιμοποιήσουμε τον τύπο:
#+BEGIN_CENTER
$\Large e = \sum_{n = 0}^{\infty} \frac{1}{n!}$
#+END_CENTER
για να υλοποιήσουμε την συνάρτηση.

Στο αρχείο =fasterApproximation.m= υλοποιήται αυτος ο τύπος και μπορεί να υπολογίσει μέχρι 50 δεκαδικά του e με 19 επαναλήψεις.
