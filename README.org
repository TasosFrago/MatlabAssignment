#+AUTHOR: Tasos Fragkopoulos
#+TITLE: Εργασία Εξαμήνου Μαθηματικό Λογισμικό
#+OPTIONS: tex:dvipng

* Εργασία Εξαμήνου Μαθηματικό Λογισμικό

** Άσκηση 1

*** Μέθοδος Επίλυσης

Για να λύσουμε την άσκηση θα πρέπει αρχικά να βρούμε τις ακτίνες κάθε κύκλου. Έστω κύκλοι A, B, C με κέντρα $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ και ακτίνες $R_1, R_2, R_3$ αντοίστοιχα, όπως φαίνεται στην εικόνα παρακάτω.

#+ATTR_HTML: width="300px"
#+ATTR_ORG: :width 300
[[./ask1/outputImage.jpg]]

Ξέρωντας τα αυτά η απόσταση μεταξύ κάθε κέντρου θα είναι:

#+BEGIN_CENTER
    $AB = R_1 + R_2$

    $AC = R_1 + R_3$

    $BC = R_2 + R_3$
#+END_CENTER

Μπορούμε να λύσουμε για $R_1, R_2, R_3$ και να βρούμε ότι:

#+BEGIN_CENTER
    $R_1 = \frac{AB + AC - BC}{2}$

    $R_2 = \frac{AB - AC + BC}{2}$

    $R_1 = \frac{-AB + AC + BC}{2}$
#+END_CENTER

Επιπλέων ξέρουμε οτι:

#+BEGIN_CENTER
    $AB = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$

    $AC = \sqrt{(x_3 - x_1)^2 + (y_3 - y_1)^2}$

    $BC = \sqrt{(x_3 - x_2)^2 + (y_3 - y_2)^2}$
#+END_CENTER

Έτσι υπολογίζοντας αρχικά τα $AB, AC, BC$ και κάνοντας τις πράξεις θα βρούμε τα $R_1, R_2, R_3$

*** Επίλυση στο Matlab

Η βασική επίλυση του προβλήματος γίνεται στο αρχείο =drawCircles.m= που έχει δύο συναρτήσεις, την =drawCircles(x, y)= και την =circle(x, y, r)=. Επίσης υπάρχει το αρχείο =example.m= που τρέχει την συνάρτηση =drawCircles= με x, y τις τιμές που δώθηκαν απο την εκφώνηση ως παράδειγμα, την χρονομετρεί με την χρήση της συνάρτησης =timeit()= του Matlab και εκτυπώνει τον χρόνο.

Στη συνάρτηση =drawCircles(x, y)= αρχικά υπολογίζουμε τις τιμές AB, AC, BC.

#+BEGIN_SRC matlab
AB = sqrt((x(2) - x(1))^2 + (y(2) - y(1))^2);
AC = sqrt((x(3) - x(1))^2 + (y(3) - y(1))^2);
BC = sqrt((x(3) - x(2))^2 + (y(3) - y(2))^2);
#+END_SRC

Ένας άλλος τρόπος να τις υπολογίσουμε θα ήταν να χρησιμοποιήσουμε την συνάρτηση =norm()=.

Στην συνέχεια φτιάχνουμε ενα διάνυσμα R, στο οποίο θα βάλουμε τις τιμές των $R_1, R_2, R_3$ που θα υπολογίσουμε.

#+BEGIN_SRC matlab
R = [];
R(1) = ( AB + AC - BC)/2;
R(2) = ( AB - AC + BC)/2;
R(3) = (-AB + AC + BC)/2;
#+END_SRC

Τέλος κάνουμε plot τις ακμές του τριγώνου και τους κύκλους. Για τους κύκλους θα χρησιμοποιούμε την βοηθητική συνάρτηση =circle(x, y, r)= που βρίσκεται στο ίδιο αρχείο. Παίρνει ως ορίσματα τις συντεταγμένες (x, y) του κέντρου του κύκλου και το μήκος της ακτίνας του r και κάνει plot τον κάθε κύκλο.

#+BEGIN_SRC matlab
function circle(x, y, r)
% CIRCLE - This function plots a circle centered at (x, y) with radius r.
%   The input arguments x, y and r are the x and y-coordinates of the center of the circle and its radius, respectively.
%   The function calculates the x and y-coordinates of 50 points evenly spaced around the circumference of the circle,
%   using the parametric equation of a circle. The function then plots the circle using the 'plot' function.

    th = 0:pi/50:2*pi;         % Theta range for 50 points
    xunit = r * cos(th) + x;   % x-coordinates of 50 points on circle
    yunit = r * sin(th) + y;   % y-coordinates of 50 points on circle
    plot(xunit, yunit);        % Plot the circle
end
#+END_SRC
Σε αυτή ορίζουμε το διάνυσμα th που έχει τις τιμές από 0 μέχρι $2\pi$ με βήμα $\frac{\pi}{50}$ και μετά υπολογίζουμε τις x και y συντεταγμένες του κύκλου στις xunit και yunit αντίστοιχα.

** Άσκηση 2

*** Επίλυση στο Matlab

Ο υπολογισμός του e με τον τύπο
#+BEGIN_CENTER
$e = \lim_{n\rightarrow \infty}(1 + \frac{1}{n})^{n}$
#+end_center
γίνεται στο *matlab*:

#+begin_src matlab
while(abs(em - e) > tol)
    e = (1 + 1/n)^n;     % approximate e using formula
    n = n * 2;           % double the value of n in each iteration
    count = count + 1;   % increment the iteration count
end
#+end_src

η λούπα τρέχει όσο η απόλυτη διαφορά του e που υπολογίζουμε με του em (που είναι το e που δίνεται απο το matlab matlab =em = exp(1)=) είναι μεγαλύτερη του tol που είναι η ακρίβεια που θέλουμε που βγαίνει από =tol = 10^-(l + 1)=.
το n διπλασιάζεται σε κάθε, επανάληψη που είναι πολύ πιο αποτελεσματικό από την αύξηση του κατά ένα.

αποτέλεσμα συνάρτησης με διπλασιασμό n:
#+begin_src
>> approximate(9)
matlab's number: 	2.718281828459
approximated number: 	2.718281828380
accuracy to point: 	          ^
number of iterations: 	35
#+end_src

αποτέλεσμα συνάρτησης με αύξηση n κατα ένα:
#+begin_src
>> approximate(9)
matlab's number: 	2.718281828459
approximated number: 	2.718281828360
accuracy to point: 	          ^
number of iterations: 	66953800
#+end_src

*** Προβλήματα με την άσκηση

Το πρόβλημα με την συνάρτηση αυτή είναι ότι δεν δουλεύει για =l > 15=. Αυτό συμβαίνει γιατί το n γίνεται πολύ μεγάλο και έτσι το =1/n= είναι τόσο μικρό που το *Matlab* στην πρόσθεση του με το 1 αγνοεί τα δεκαδικά, με αποτέλεσμα το e να γίνει 1.

Μια λύση για να αντιμετοπίσουμε το πρόβλημα αυτό είναι να χρησιμοποιήσουμε την συνάρτηση =vpa()= του [[https://www.mathworks.com/help/symbolic/][*Symbolic Math Toolbox*]] για να κάνουμε την πράξη. Βέβαια κάνει την συνάρτηση πολύ πιο αργή.

Ο πιο αποτελεσματικός τρόπος είναι να χρησιμοποιήσουμε τον τύπο:
#+BEGIN_CENTER
$\Large e = \sum_{n = 0}^{\infty} \frac{1}{n!}$
#+END_CENTER
για να υλοποιήσουμε την συνάρτηση.

Στο αρχείο  =fasterApproximation.m= υλοποιήται αυτος ο τύπος και μπορεί να υπολογίσει μέχρι 50 δεκαδικά του e με 19 επαναλήψεις.

** Άσκηση 3

*** Μέθοδος Επίλυσης

Για την λύση του προβλήματος αυτού θα χρειαστούμε να φτιάξουμε αρχικά ενα διάνυσμα 26 θέσεων. Κάθε θέση του διανύσματος θα αντιπροσοπεύει ένα γράμμα του λατινικού αλφαβήτου και θα περιέχει το πλήθος εμφάνισης του.

Θα το αρχηκοποιήσουμε με μηδενικά
#+BEGIN_SRC matlab
alphabet = zeros(1, 26);
#+END_SRC

Έπειτα θα διατρέξουμε κάθε χαρακτήρα της ακολουθίας χαρακτήρων και θα ελέγχουμε αν η τιμή ascii του είναι μεταξύ του 65 - 90 ή 97 - 122. Μεταξύ του 65 - 90 είναι οι τα κεφαλαία γράμματ και του 97 - 122 είναι τα μικρά. Έτσι διασφαλίζουμε οτι αγνοούμε όλους τους άλλους χαρακτήρες. Αφού ελένξουμε τους χαρακτήρες κάνουμε την αναγκαία αφαίρεση για να βάλουμε τον κάθε χαρακτήρα στο διάνυσμα alphabet.

#+begin_src matlab
% Scan the input string `str`
for i = 1:strlength(str)

    % If a character in the string is between ASCII values 65 and 90 (upper case letters),
    % its count is increased in the `alphabet` array at the corresponding index (`str(i) - 64`).
    if(str(i) >= 65 && str(i) <= 90)
        alphabet(str(i) - 64) = alphabet(str(i) - 64) + 1;

    % If a character is between ASCII values 97 and 122 (lower case letters),
    % its count is increased in the `alphabet` array at the corresponding index (`str(i) - 96`).
    elseif (str(i) >= 97 && str(i) <= 122)
        alphabet(str(i) - 96) = alphabet(str(i) - 96) + 1;
    end
end
#+end_src

Τέλος διατρέχουμε το διάνυσμα alphabet και εκτυπώνουμε τα γράμματα και πόσες φορές εμφανίζονται.

#+begin_src matlab
% Output the number of occurrences of each letter in the string
for i = 1:26
    if(alphabet(i) ~= 0)
        fprintf("Found %c: %d times \n", (i+96), alphabet(i));
    end
end
#+end_src

Παράδειγμα χρήσης συνάρτησης για ακολουθία χαρακτήρων 'Hello World':
#+begin_src shell
>> findOccurances('Hello World')
Found d: 1 times
Found e: 1 times
Found h: 1 times
Found l: 3 times
Found o: 2 times
Found r: 1 times
Found w: 1 times
#+end_src
